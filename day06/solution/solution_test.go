package solution

import (
	"reflect"
	"testing"
)

func TestGetStartPosition(t *testing.T) {
	guardMap := [][]string{
		{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
		{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
		{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
		{".", "#", ".", ".", "^", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
		{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
	}
	wantDirection, wantRowIndex, wantColumnIndex := "^", 6, 4
	gotDirection, gotRowIndex, gotColumnIndex := getStartPosition(guardMap)

	if gotDirection != wantDirection {
		t.Errorf("got: %v, but want %v", gotDirection, wantDirection)
	}
	if gotRowIndex != wantRowIndex {
		t.Errorf("got: %v, but want %v", gotRowIndex, wantRowIndex)
	}
	if gotColumnIndex != wantColumnIndex {
		t.Errorf("got: %v, but want %v", gotColumnIndex, wantColumnIndex)
	}
}

func TestCheckNextStepMap(t *testing.T) {
	t.Run("^ case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", "^", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", "^", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", "X", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("v case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", "v", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", "X", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", "v", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("< case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", "<", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", "<", "X", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("> case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ">", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", "X", ">", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("^# case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", "^", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ">", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("v# case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", "v", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", "<", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("#< case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", "<", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", "^", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("># case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ">", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}
		want := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "v", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
		}

		got, _ := checkNextStepMap(guardMap)

		if reflect.DeepEqual(got, want) == false {
			t.Errorf("got: %v, but want %v", got, want)
		}
	})

	t.Run("done case", func(t *testing.T) {
		guardMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", "v", ".", "."},
		}
		wantMap := [][]string{
			{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", "#", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
			{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
			{".", ".", ".", ".", ".", ".", "#", "X", ".", "."},
		}

		gotMap, gotDone := checkNextStepMap(guardMap)

		if reflect.DeepEqual(gotMap, wantMap) == false {
			t.Errorf("got: %v, but want %v", gotMap, wantMap)
		}
		if gotDone != true {
			t.Errorf("got: %v, but want %v", gotDone, true)
		}
	})
}

func TestGetFinalMap(t *testing.T) {
	guardMap := [][]string{
		{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", ".", ".", "#"},
		{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
		{".", ".", "#", ".", ".", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", "#", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", ".", ".", "."},
		{".", "#", ".", ".", "^", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", ".", ".", "#", "."},
		{"#", ".", ".", ".", ".", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", ".", ".", "#", ".", ".", "."},
	}

	want := [][]string{
		{".", ".", ".", ".", "#", ".", ".", ".", ".", "."},
		{".", ".", ".", ".", "X", "X", "X", "X", "X", "#"},
		{".", ".", ".", ".", "X", ".", ".", ".", "X", "."},
		{".", ".", "#", ".", "X", ".", ".", ".", "X", "."},
		{".", ".", "X", "X", "X", "X", "X", "#", "X", "."},
		{".", ".", "X", ".", "X", ".", "X", ".", "X", "."},
		{".", "#", "X", "X", "X", "X", "X", "X", "X", "."},
		{".", "X", "X", "X", "X", "X", "X", "X", "#", "."},
		{"#", "X", "X", "X", "X", "X", "X", "X", ".", "."},
		{".", ".", ".", ".", ".", ".", "#", "X", ".", "."},
	}
	got := GetFinalMap(guardMap)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("got: %v, but want %v", got, want)
	}
}
